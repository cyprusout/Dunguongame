<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<link rel="icon" type="image/x-icon" href="icon.png">
	<style>
		canvas{
			background-color:black;
		}
		game{
			display: flex;
		}
		div > img{
			box-sizing: border-box;
			border: 0;
		}
		.selected{
			border: 2px solid red;
		}
		#edit{
			visibility: hidden;
		}
	</style>
	<script src="helpers.js"></script>
	<script src="bar.js"></script>
	<script src="sprite.js"></script>
	<script src="input.js"></script>
	<script src="audio.js"></script>
</head>
<body>
	<game>
		<canvas width=1200 height=800></canvas>
		<div id=edit>
			<button id=set_map>Choose Map</button>
			<button id=spawn_point>Set Spawn Point</button>
			<button id=draw_line>Draw Collision Line</button>
			<button id=draw_circle>Draw Collision Circle</button>
			<button id=save>Download Level</button>
			<input title="Sprite Spawn Delay" id=time_delay type=checkbox>
			<br>
		</div>
	</game>
	<script>
		const canvas = obj('canvas');
		const ctx = canvas.getContext('2d');
		ctx.fillStyle = 'white';
		ctx.font = '40px sans-serif';
		ctx.fillText('Press Space to Start',50,50);
		ctx.fill();

		var EDITOR = location.href.includes('editor');

		var sel_sprite=null;

		var player = new Sprite('Player/0.png');
		player.addAnimation('Player/player.anims');
		player.maxHealth = 30;
		var DRAW_MODE = 0,o_pos = null;

		var bullets = [];
		var enemies = [];
		var sprites = [];
		var my_bullets = [];
		var lines = [];
		var GAME = 0;
		var edit_sprite = null;
		var INVENTORY = [],inv_cache=[];

		document.on('keydown',e=>{
			if(e.key == ' '){
				start();
			}
			if(e.key == '`'){
				useOmegaSword();
			}
		});

		keys.start();
		mouse.start(canvas);

		var background;

		function loadMap(name='sandmap'){
			return new Promise((res,rej)=>{
				background = new Sprite(`maprooms/${name}.png`,res);
				background.position = new Vector(0,0);
			})
		}
		function loadLines(lns=[]){
			lines = [];
			for(let l of lns){
				lines.push(new Line(l.x1,l.y1,l.x2,l.y2));
			}
		}

		loadMap();

		class Bullet extends Sprite{
			constructor(x,y,d,path='bullet.png'){
				super(path);
				this.position = new Vector(x,y);
				this.direction = d;
				this.speed = 3.5;
				this.parr = bullets;
			}
			fly(){
				let pos = this.pos;
				pos.x += this.speed * Math.cos(this.dir*Math.PI/180);
				pos.y += this.speed * Math.sin(this.dir*Math.PI/180);
				this.position = pos;
				if(pos.y > background.h/2 || pos.y < -background.h/2 || pos.x < -background.w/2 || pos.x > background.w/2){
					this.parr.splice(this.parr.indexOf(this),1);
				}
				if(this.touches(player)){
					this.parr.splice(this.parr.indexOf(this),1);
					player.health--;
				}
				if(this.isTouchingLines()){
					this.parr.splice(this.parr.indexOf(this),1);
				}
			}
		}

		var imgs = [
			{ix:0,name:'Tri1',path:'enemies/bushman.png'},
			{ix:1,name:'FireFly',path:'enemies/fireshooter.png'},
			{ix:2,name:'WaterBlob',path:'enemies/waterblob/0.png'},
			{ix:3,name:'Tree',path:'levelitems/tree.png'},
			{ix:4,name:'Door',path:'levelitems/door/0.png',p:1 },
            {ix:5,name:'LaserBull',path:'enemies/LaserBull.png'},
            {ix:6,name:'Spike',path:'enemies/spikes.png'},
            {ix:7,name:'SandWorm',path:'enemies/sandworm/00.png'},
		];

		function setupTools(){
			show(obj('#edit'));
			for(let sprite of imgs){
				let i = new Image;
				i.src = sprite.path;
				i.width = 50;
				obj('#edit').appendChild(i);
				sprite.el = i;
				i.on('click',e=>{
					if(sel_sprite) sel_sprite.el.classList.remove('selected');
					sel_sprite = sprite;
					edit_sprite = new Sprite(sprite.path);
					i.classList.add('selected');
				})
			}
		}
				this.nextRoom = 'level0';
				this.activated = false;

		class Tri1 extends Sprite{
			constructor(x,y){
				super('enemies/bushman.png');
				this.speed = .5;
				this.position = new Vector(x,y);
				this.cooldown = 60;
				this.maxHealth = 40;
                this.health = this.maxHealth;
				this.md = 80 * ((Math.random() > .5) ? -1 : 1);
				enemies.push(this);
			}
			attack(){
				let x = this.pos.x;
				let y = this.pos.y;
				let d = Vector.getDir(x-player.pos.x,y-player.pos.y);
				this.direction = d;
				let pos = this.pos;
				d += this.md;
				pos.x += this.speed * Math.cos(d*Math.PI/180);
				pos.y += this.speed * Math.sin(d*Math.PI/180);
				this.position = pos;
				if(this.touches(background) || this.isTouchingLines()){
					this.md *= -1;
				}
				this.cooldown--;
				d -= this.md;
				if(this.cooldown == 0){
					this.cooldown = 60;
					let b1 = new Bullet(pos.x,pos.y,d,'enemies/thorn.png');
					let b2 = new Bullet(pos.x,pos.y,d-35,'enemies/thorn.png');
					let b3 = new Bullet(pos.x,pos.y,d+35,'enemies/thorn.png');
					bullets.push(b1,b2,b3);
				}
			}
		}
		class FireFly extends Sprite{
			constructor(x,y){
				super('enemies/fireshooter.png');
				this.speed = 4;
				this.position = new Vector(x,y);
				this.cooldown1 = 2;
				this.cooldown2 = -200;
				this.maxHealth = 40;
                this.health = this.maxHealth;
				this.md = 0 * ((Math.random() > .5) ? -1 : 1);
				enemies.push(this);
			}
			attack(){
				let x = this.pos.x;
				let y = this.pos.y;
				let pos = this.pos;
				let d = this.dir;
				pos.x += this.speed * Math.cos(d*Math.PI/180);
				pos.y += this.speed * Math.sin(d*Math.PI/180);
				this.position = pos;
				this.cooldown1--;
				this.cooldown2--;
				if(this.cooldown1 == 0 && this.cooldown2 > 0){
					this.cooldown1 = 1;
					let b1 = new Bullet(pos.x,pos.y,d+random(-10,10),'enemies/fireball.png');
					// audio.play('creek.wav',true,1);
					b1.speed = 15;
					bullets.push(b1);
				} else {
					// audio.stopAll();
				}
				if(this.cooldown2 < -300){
					this.cooldown2 = random(150,300);
					this.cooldown1 = 1;
					let d = Vector.getDir(x-player.pos.x,y-player.pos.y);
					this.direction = d;
				}
			}
		}
		class WaterBlob extends Sprite{
			constructor(x,y){
				super('enemies/waterblob/0.png');
				this.speed = .5;
				this.position = new Vector(x,y);
				this.cooldown = 60;
				this.maxHealth = 40;
                this.health = this.maxHealth;
				this.md = 80 * ((Math.random() > .5) ? -1 : 1);
				this.addAnimation('enemies/waterblob/waterblob.anims').then(()=>{
					this.animation.play('idle',true);
				});
				enemies.push(this);
			}
			attack(){
				let x = this.pos.x;
				let y = this.pos.y;
				let d = Vector.getDir(x-player.pos.x,y-player.pos.y);
				// this.direction = d;
				let pos = this.pos;
				// pos.x += this.speed * Math.cos(d*Math.PI/180);
				// pos.y += this.speed * Math.sin(d*Math.PI/180);
				// this.position = pos;
				this.cooldown--;
				if(this.cooldown == 0){
					this.cooldown = 60;
                    var bulletcount = random(4, 10)
					for (let i = 0; i < 360; i += 360 / bulletcount){
						let nb = new Bullet(pos.x,pos.y,i,'enemies/waterblob/waterbullet.png');
						bullets.push(nb);
					}
				}
			}
		}
		class Tree extends Sprite{
			constructor(x,y){
				super('levelitems/tree.png');
				this.position = new Vector(x,y);
				sprites.push(this);
			}
		}
		class Door extends Sprite{
			constructor(x,y){
				super('levelitems/door/0.png');
				this.addAnimation('levelitems/door/door.anims').then(e=>{
					this.animation.play((this.activated&&!this.touches(player))?'open':'closed',true);
					if(!this.touches(player)){
						this.playerCheck = true;
					}
				});
				this.position = new Vector(x,y);
				this.nextRoom = 'level0';
				this.activated = false;
				this.playerCheck = false;
				this.addMovement(this.check);
				sprites.push(this);
			}
			activate(){
				this.activated = true;
				this.animation.play('open',true);
			}
			check(){
				if(!this.playerCheck){
					if(!this.touches(player)){
						this.playerCheck = true;
						try{this.animation.play((this.activated)?'open':'closed',true);}catch(e){}
					} else {
						return;
					}
				}
				if(this.activated){
					if(this.touches(player)){
						let d = this.dir + 180;
						let rx = player.pos.x / (background.w/2);
						let ry = player.pos.y / (background.h/2);
						if(Math.abs(player.pos.x) > Math.abs(player.pos.y)){
							ry=0;
							rx*=.9;
						} else {
							rx=0;
							ry*=.9;
						}
						rx *= -1;
						ry *= -1;
						loadLevel(this.nextRoom,new Vector(rx,ry));
					}
				} else {
					if(enemies.length == 0){
						setTimeout(()=>{
							this.activate();
						},500);
					}
				}
			}
			loadSpecCode(spec){
				let d = spec.split(',');
				this.activated = d[0]=='1';
				this.nextRoom = d[1];
			}
		}
		class LaserBull extends Sprite{
            constructor(x, y) {
                super('enemies/LaserBull.png');
                this.speed = 2;
                this.position = new Vector(x, y);
                this.cooldown = 30;
                this.maxHealth = 30;
                this.health = this.maxHealth;
				this.md = 60 * ((Math.random() > .5) ? -1 : 1);
				this.mode = 0;
                enemies.push(this);
            }
            attack() {
                let x = this.pos.x;
                let y = this.pos.y;
                let d = Vector.getDir(x - player.pos.x, y - player.pos.y);
                this.direction = d;
				let pos = this.pos.clone();
                d += this.md;
                pos.x += this.speed * Math.cos(d * Math.PI / 180);
                pos.y += this.speed * Math.sin(d * Math.PI / 180);
                this.position = pos;
                if (this.touches(background) || this.isTouchingLines()) {
                    this.md *= -1;
                }
                this.cooldown--;
				d -= this.md;
				//red laser (straight)
				if (this.cooldown == 0) {
					this.cooldown = 30;
					if (this.mode == 0) {
						let b1 = new Bullet(pos.x, pos.y, d, 'enemies/LaserRed.png');
                        let b2 = new Bullet(pos.x, pos.y, d, 'enemies/LaserRed.png');
						b1.speed = 4;
						b2.speed = -1;
						this.mode = 1;
					bullets.push(b1, b2);
					} else {
						let b1 = new Bullet(pos.x, pos.y, d + 15, 'enemies/LaserRed.png');
						let b2 = new Bullet(pos.x, pos.y, d - 15, 'enemies/LaserRed.png');
                        let b3 = new Bullet(pos.x, pos.y, d + 15, 'enemies/LaserRed.png');
                        let b4 = new Bullet(pos.x, pos.y, d - 15, 'enemies/LaserRed.png');
                        b1.speed = 4;
						b2.speed = 4;
                        b3.speed = -1;
                        b4.speed = -1;
						this.mode = 0;
                        bullets.push(b1, b2, b3, b4);
						}
                }
            }
        }
		class Spike extends Sprite{
			constructor(x,y){
				super('enemies/spikes.png');
				this.position = new Vector(x,y);
				sprites.push(this);
				this.addMovement(this.stab);
				this.touchingPlayer = false;
			}
			stab(){
				if(this.touches(player)){
					if(!this.touchingPlayer) player.health--;
					this.touchingPlayer = true;
				} else {
					this.touchingPlayer = false;
				}
			}
		}
		class SandWorm extends Sprite{
			constructor(x,y){
				super('enemies/sandworm/00.png');
				this.position = new Vector(x,y);
				enemies.push(this);
				this.addAnimation('enemies/sandworm/sandworm.anims');
				this.inHole = true;
				this.cooldown = 300;
				this.speed = 5;
				this.maxHealth = 35;
				this.health = this.maxHealth;
				this.visible = false;
				this.doDamage = false;
				this.shouldMove = false;
				this.scale.x = .25;
				this.scale.y = .8;
			}
			attack(){
				this.cooldown--;
				if(this.shouldMove){
					let p = this.pos.clone();
					p.x += this.speed * Math.cos(this.dir*Math.PI/180);
					p.y += this.speed * Math.sin(this.dir*Math.PI/180);
					this.position = p;
				}
				if(this.touches(player) && this.doDamage){
					player.health--;
				}
				if(this.cooldown == 0){
					if(this.inHole){
						this.playAnimation();
						var pos_off = player.pos.clone();
						if(Math.random() < .5){
							this.direction = 180 * random(0,1);
							this.offset.x = (-10+this.w/2) * Math.cos(this.dir);
							this.offset.y = 0;
						} else {
							this.direction = 90 + 180 * random(0,1);
							this.offset.x = 0;
							this.offset.y = (-10+this.w/2) * Math.sin(this.dir);
						}
						this.position = Vector.getPointIn(Vector.rad(this.dir+180),150,pos_off.x,pos_off.y);
					}
				}
			}
			async playAnimation(){
				this.inHole = false;
				this.visible = true;
				await this.animation.play('show');
				this.shouldMove = true;
				// await this.animation.play('slither');
				this.doDamage = true;
				await this.animation.play('attack');
				await this.animation.play('attack');
				this.doDamage = false;
				this.shouldMove = false;
				await this.animation.play('hide');
				this.visible = false;
				this.inHole = true;
				this.cooldown = 300;
			}
		}

		Sprite.prototype.healthBar = new Bar(0,0,50,10);
		Sprite.prototype.showHealth = function(){
			if(this.visible){
				this.healthBar.pert = this.health / this.maxHealth;
				this.healthBar.draw(this.pos.x,this.pos.y-this.h/2-5);
			}
		}
		Sprite.prototype.isTouchingLines = function(){
			for(let l of lines){
				if(this.touches(l)){
					return true;
				}
			}
			return false;
		}


		var classes = imgs.map(e=>e.name);

		function spawnSprites(sprts,EDITOR=false){
			enemies = [];
			sprites = [];
			for(let sprite of sprts){
				let w = +sprite.w;
				setTimeout(()=>{
					let ns = eval(`new ${classes[sprite.i]}`);
					ns.position = new Vector(sprite.x,sprite.y);
					if(sprite.spec){
						ns.loadSpecCode(sprite.spec);
					}
					if(sprite.d){
						ns.direction = sprite.d;
					}
				},w*1000);
			}
		}

		function EDITOR_EVENTS(){
			document.on('wheel',e=>{
				if(edit_sprite){
					edit_sprite.direction = edit_sprite.dir + 90;
				}
			});
		}
		function EDITOR_CONTROLS(){
			if(mouse.right){
				edit_sprite = null;
				if(sel_sprite) sel_sprite.el.classList.remove('selected');
				sel_sprite = null;
			}
			if(sel_sprite && mouse.down){
				let ne = new Sprite(sel_sprite.path);
				ne.direction = edit_sprite.dir;
				ne.position = new Vector(mouse.pos.x-canvas.width/2+player.pos.x,mouse.pos.y-canvas.height/2+player.pos.y);
				sprites.push(ne);
				mouse.down = false;
				var spec = '';
				var w = 0;
				if(obj('#time_delay').checked){
					w = prompt('Enter delay (in seconds) before this item spawns');
				}
				var result = {i:sel_sprite.ix,x:ne.pos.x,y:ne.pos.y,w,d:edit_sprite.dir};
				if(sel_sprite.p == 1){
					let a = prompt('Is Active (1/0)');
					let b = prompt('Where does this door lead to (enter level name)')
					if(!a) a='0';
					if(!b) b='level0';
					result.spec = a+','+b;
				}
				level_data.spts.push(result);
			}
			if(mouse.down){
				if(DRAW_MODE==1){
					if(!o_pos){
						o_pos = new Vector(mouse.pos.x-canvas.width/2+player.pos.x,mouse.pos.y-canvas.height/2+player.pos.y);
					} else {
						ctx.beginPath();
						ctx.moveTo(o_pos.x,o_pos.y);
						ctx.lineTo(mouse.pos.x-canvas.width/2+player.pos.x,mouse.pos.y-canvas.height/2+player.pos.y);
						ctx.stroke();
					}
				}
			}
			if(!mouse.down){
				if(DRAW_MODE == 1){
					if(o_pos){
						lines.push(new Line(o_pos.x,o_pos.y,mouse.pos.x-canvas.width/2+player.pos.x,mouse.pos.y-canvas.height/2+player.pos.y));
						o_pos = null;
					}
				}
			}
			obj('#set_map').on('click',e=>{
				keys.keys['m'] = true;
			});
			if(keys.down('m')){
				keys.keys['m'] = false;
				let nm = prompt('Enter map Name');
				if(nm){
					loadMap(nm);
					level_data.map = nm;
					sprites = [];
					lines = [];
					enemies = [];
					level_data.lines = [];
					level_data.spts = [];
				}
			}
			obj('#spawn_point').on('click',e=>{
				level_data.sx = player.pos.x;
				level_data.sy = player.pos.y;
			});
			obj('#save').on('click',e=>{
				keys.keys['q'] = true;
			});
			if(keys.down('q')){
				dataExtraction();
				keys.keys['q'] = false;
				download(`${level_data.map}.json`,JSON.stringify(level_data));
			}
			obj('#draw_line').on('click',e=>{
				if(sel_sprite) sel_sprite.el.classList.remove('selected');
				sel_sprite = null;
				DRAW_MODE = 1;
			});
		}

		function dataExtraction(){
			if(!level_data.lines) level_data.lines = [];
			for(let l of lines){
				let p1 = l.getPosA();
				let p2 = l.getPosB();
				level_data.lines.push({x1:p1.x,y1:p1.y,x2:p2.x,y2:p2.y});
			}
		}

		function inputHandle(){
			let speed = 4;
			let pos = player.pos.clone();
			if(keys.down('w')){
				pos.y -= speed;
			}
			if(keys.down('s')){
				pos.y += speed;
			}
			if(keys.down('a')){
				pos.x -= speed;
				if(player.health > 0) player.transformX = -1;
			}
			if(keys.down('d')){
				pos.x += speed;
				if(player.health > 0) player.transformX = 1;
			}
			if(keys.down('w') || keys.down('a') || keys.down('s') || keys.down('d')){
				if(player.health > 0) player.animation.play('walk');
			} else {
				player.animation.stop();
			}
			if(keys.down('e')){
				keys.keys['e'] = false;
				nWeapon();
			}

			pos.x = Math.max(Math.min(pos.x,background.w/2),-background.w/2);
			pos.y = Math.max(Math.min(pos.y,background.h/2),-background.h/2);
			let op = player.pos.clone();

			player.position = new Vector(pos.x,op.y);
			if(player.isTouchingLines()) pos.x = op.x;


			player.position = new Vector(op.x,pos.y);
			if(player.isTouchingLines()) pos.y = op.y;

			if(player.health > 0){
				player.position = pos;
				weapon.direction = Vector.getDir(canvas.width/2-mouse.pos.x,canvas.height/2-mouse.pos.y);
				weapon.position = Vector.getPointIn(weapon.dir * Math.PI / 180,weapon_dist,pos.x,pos.y);
			} else {
				player.position = op;
			}
			if(EDITOR){
				EDITOR_CONTROLS();
			}
		}


		var itemframe = new Image;
		itemframe.src = 'itemframe.png';

		INVENTORY.push({name:'hp',path:'potion/0.png'});

		function drawInventory(){
			for(let i=0;i<Math.max(INVENTORY.length,3);i++){
				let x = i*(itemframe.width+5)+5;
				let y = canvas.height-itemframe.height-5;
				ctx.drawImage(itemframe,x,y,64,64);
				if(INVENTORY[i]){
					let it = new Image;
					it.src = INVENTORY[i].path;
					ctx.drawImage(it,x+itemframe.width/2-it.width/2,y+itemframe.height/2-it.height/2);
					if(mouse.down && mouse.pos.x > x && mouse.pos.y > y && mouse.pos.x < x+64 && mouse.pos.y < y+64){
						useItem(INVENTORY[i]);
						INVENTORY.splice(i,1);
					}
				}
			}
		}

		var level_data = {spts:[],map:'sandmap',sx:0,sy:0,lines:[]};

		function useSpear(){
			weapon = new Sprite('weapons/spear/0.png');
			weapon.addAnimation('weapons/spear/stab.anims');
			weapon.scale = new Vector(1,.3);
			weapon.damage = 1;
			weapon_action = 'stab';
			weapon_dist = 25;
		}
		function useMace(){
			weapon = new Sprite('weapons/mace/0.png');
			weapon.addAnimation('weapons/mace/mace.anims');
			weapon_action = 'swing';
			weapon.damage = 3;
			weapon_dist = 20;
			weapon.transformX = -1;
		}
		function useLongSword(){
			weapon = new Sprite('weapons/longsword/0.png');
			weapon.addAnimation('weapons/longsword/longsword.anims');
			weapon_action = 'swing';
			weapon.damage = 3;
			weapon_dist = 40;
			weapon.transformX = -1;
		}
		function useKnives(){
			weapon = new Sprite('weapons/knives/0.png');
			weapon.addAnimation('weapons/knives/knife.anims');
			weapon_action = 'stab';
			weapon.damage = 3;
			weapon_dist = 15;
		}
		function useSword(){
			weapon = new Sprite('weapons/sword/0.png');
			weapon.addAnimation('weapons/sword/sword.anims');
			weapon_action = 'swing';
			weapon.damage = 3;
			weapon_dist = 20;
			weapon.transformX = -1;
		}
		function useCrossbow(){
			weapon = new Sprite('weapons/crossbow/0.png');
			weapon.addAnimation('weapons/crossbow/crossbow.anims');
			weapon.damage = 3;
			weapon_dist = 20;
			weapon.type = 'nod';
			weapon.transformX = -1;
		}
		function useOmegaSword(){
			weapon = new Sprite('weapons/yaldabaoth/0.png');
			weapon.addAnimation('weapons/yaldabaoth/yaldabaoth.anims');
			weapon.damage = 9999;
			weapon_dist = 55;
			weapon_action = 'stab';
		}

		function useItem(item){
			if(item.name=='hp'){
				player.health = player.maxHealth;
			}
		}

		function attack(){
			try{
				if(weapon.type == 'nod'){
					weapon.animation.play('load').then(d=>{
						let arrow = new Bullet(weapons.pos.x,weapon.pos.y,weapon.dir,'weapons/arrow.png');
						arrow.parr = my_bullets;
						weapon.animation.play('fire');
					});
				} else {
					weapon.animation.play(weapon_action).then(d=>{
						if(!d) return;
						for(let e of enemies){
							if(weapon.touches(e)){
								if(e.visible) e.health -= weapon.damage;
								if(e.health <= 0){
									enemies.splice(enemies.indexOf(e),1);
									let poof = new Sprite('poof/0.png');
									poof.position = new Vector(e.pos.x,e.pos.y);
									poof.addAnimation('poof/poof.anims').then(e=>{
										poof.animation.play('poof').then(e=>{
											sprites.splice(sprites.indexOf(poof),1);
										});
									});
									sprites.push(poof);
								}
							}
						}
					});
				}
			} catch(e){
				console.log('Animation didn\'t load fast enough');
			} 
		}

		var equips = [useSpear,useMace,useLongSword,useKnives,useSword,useCrossbow];
		var weapon_ix = 0;

		function nWeapon(){
			if(player.health >= 0){
				weapon_ix = (weapon_ix+1) % equips.length;
				equips[weapon_ix]();
			}
		}

		var weapon;
		var weapon_action = '';
		var weapon_dist = 0;

		useSpear();

		function start(){
			if(!started){
				let lv_name = location.href.split('level=')[1];
				if(EDITOR) EDITOR_EVENTS();
				player.health = player.maxHealth;
				loadLevel(lv_name);
				if(EDITOR){
					setupTools();
				}
			}
			if(!FULLSCREEN && !EDITOR) canvas.requestFullscreen();
		}

		async function loadLevel(level_name='sandroomspawn',v){
			stopGame();
			let req = await fetch(`levels/${level_name}.json`);
			level_data = await req.json();
			await loadMap(level_data.map);
			spawnSprites(level_data.spts,EDITOR);
			loadLines(level_data.lines);
			started = true;
			loop();
			if(v){
				player.position = v.mult(background.w/2);
			} else {
				player.position = new Vector(level_data.sx,level_data.sy);
			}
			if(!EDITOR && !FULLSCREEN) canvas.requestFullscreen();
		}

		Hitbox.show = false;

		var started = false;

		function stopGame(){
			started = false;
			if(typeof GAME == 'number') clearTimeout(GAME);
		}

		function loop(){
			ctx.clearRect(-2,-2,canvas.width+2,canvas.height+2);
			GAME = setTimeout(loop,1000/60);
			ctx.save();
			ctx.translate(-player.pos.x+canvas.width/2,-player.pos.y+canvas.height/2);
			background.draw();
			inputHandle();
			player.draw();
			player.showHealth();
			if(player.health <= 0){
				player.health = 0;
				player.direction = 90;
			}
			for(let s of sprites) s.draw();
			if(!EDITOR){
				for(let b of bullets){
					b.fly();
					b.draw();
				}
			}
			if(EDITOR || Hitbox.show){
				for(let l of lines){
					l.draw();
				}
			}
			for(let e of enemies){
				if(!EDITOR){
					e.attack();
					e.showHealth();
				}
				e.draw();
			}
			weapon.draw();
			if(mouse.down && !EDITOR && player.health > 0){
				attack();
			}
			ctx.restore();
			drawInventory();
			if(EDITOR && edit_sprite){ 
				edit_sprite.position = new Vector(mouse.pos.x,mouse.pos.y);
				ctx.globalAlpha = .5;
				edit_sprite.draw();
				ctx.globalAlpha = 1;
			}
		}

		function shoot(){
			let x = random(0,canvas.width);
			let y = 0;
			// let d = Vector.getDir(x-player.pos.x,y-player.pos.y);
			let d = 90;
			let nb = new Bullet(x,y,d);
			bullets.push(nb);
		}

	</script>
</body>
</html>