<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<link rel="icon" type="image/x-icon" href="icon.png">
	<style>
		canvas{
			background-color:black;
		}
		game{
			display: flex;
		}
		div > img{
			box-sizing: border-box;
			border: 0;
		}
		.selected{
			border: 2px solid red;
		}
		#edit{
			visibility: hidden;
		}
	</style>
	<script src="helpers.js"></script>
	<script src="bar.js"></script>
	<script src="sprite.js"></script>
	<script src="input.js"></script>
	<script src="audio.js"></script>
</head>
<body>
	<game>
		<canvas width=1200 height=800></canvas>
		<div id=edit>
			<button id=set_map>Choose Map</button>
			<button id=spawn_point>Set Spawn Point</button>
			<button id=draw_line>Draw Collision Line</button>
			<button id=draw_circle>Draw Collision Circle</button>
			<button id=save>Download Level</button>
			<input title="Sprite Spawn Delay" id=time_delay type=checkbox>
			<br>
		</div>
	</game>
	<script>
		const canvas = obj('canvas');
		const ctx = canvas.getContext('2d');
		ctx.fillStyle = 'white';
		ctx.font = '40px sans-serif';
		ctx.fillText('Press Space to Start',50,50);
		ctx.fill();

		//////////////////////////////////////////////////
		var EDITOR = location.href.includes('editor');
		//////////////////////////////////////////////////

		var sel_sprite=null;

		var player = new Sprite('Player/0.png');
		player.maxHealth = 30;
		var DRAW_MODE = 0,o_pos = null;

		var bullets = [];
		var enemies = [];
		var sprites = [];
		var lines = [];
		var GAME = 0;

		document.on('keydown',e=>{
			if(e.key == ' '){
				start();
			}
		});

		keys.start();
		mouse.start(canvas);

		var background;

		function loadMap(name='sandmap'){
			background = new Sprite(name+'.png');
			background.position = new Vector(0,0);
		}
		function loadLines(lns=[]){
			for(let l of lns){
				lines.push(new Line(l.x1,l.y1,l.x2,l.y2));
			}
		}

		loadMap();

		class Bullet extends Sprite{
			constructor(x,y,d,path='bullet.png'){
				super(path);
				this.position = new Vector(x,y);
				this.direction = d;
				this.speed = 3.5;
			}
			fly(){
				let pos = this.pos;
				pos.x += this.speed * Math.cos(this.dir*Math.PI/180);
				pos.y += this.speed * Math.sin(this.dir*Math.PI/180);
				this.position = pos;
				if(pos.y > background.h/2 || pos.y < -background.h/2 || pos.x < -background.w/2 || pos.x > background.w/2){
					bullets.splice(bullets.indexOf(this),1);
				}
				if(this.touches(player)){
					bullets.splice(bullets.indexOf(this),1);
					player.health--;
				}
				if(this.isTouchingLines()){
					bullets.splice(bullets.indexOf(this),1);
				}
			}
		}

		var imgs = [
			{ix:0,name:'Tri1',path:'bushman.png'},
			{ix:1,name:'FireFly',path:'fireshooter.png'},
			{ix:2,name:'WaterBlob',path:'waterblob/0.png'},
		];

		function setupTools(){
			show(obj('#edit'));
			for(let sprite of imgs){
				let i = new Image;
				i.src = sprite.path;
				i.width = 50;
				obj('#edit').appendChild(i);
				sprite.el = i;
				i.on('click',e=>{
					if(sel_sprite) sel_sprite.el.classList.remove('selected');
					sel_sprite = sprite;
					i.classList.add('selected');
				})
			}
		}

		class Tri1 extends Sprite{
			constructor(x,y){
				super('bushman.png');
				this.speed = .5;
				this.position = new Vector(x,y);
				this.cooldown = 60;
				this.maxHealth = 40;
				this.md = 80 * ((Math.random() > .5) ? -1 : 1);
				enemies.push(this);
			}
			attack(){
				let x = this.pos.x;
				let y = this.pos.y;
				let d = Vector.getDir(x-player.pos.x,y-player.pos.y);
				this.direction = d;
				let pos = this.pos;
				d += this.md;
				pos.x += this.speed * Math.cos(d*Math.PI/180);
				pos.y += this.speed * Math.sin(d*Math.PI/180);
				this.position = pos;
				if(this.touches(background) || this.isTouchingLines()){
					this.md *= -1;
				}
				this.cooldown--;
				d -= this.md;
				if(this.cooldown == 0){
					this.cooldown = 60;
					let b1 = new Bullet(pos.x,pos.y,d);
					let b2 = new Bullet(pos.x,pos.y,d-35);
					let b3 = new Bullet(pos.x,pos.y,d+35);
					bullets.push(b1,b2,b3);
				}
			}
		}
		class FireFly extends Sprite{
			constructor(x,y){
				super('fireshooter.png');
				this.speed = 3;
				this.position = new Vector(x,y);
				this.cooldown1 = 2;
				this.cooldown2 = -200;
				this.maxHealth = 40;
				this.md = 0 * ((Math.random() > .5) ? -1 : 1);
				enemies.push(this);
			}
			attack(){
				let x = this.pos.x;
				let y = this.pos.y;
				let pos = this.pos;
				let d = this.dir;
				pos.x += this.speed * Math.cos(d*Math.PI/180);
				pos.y += this.speed * Math.sin(d*Math.PI/180);
				this.position = pos;
				this.cooldown1--;
				this.cooldown2--;
				if(this.cooldown1 == 0 && this.cooldown2 > 0){
					this.cooldown1 = 1;
					let b1 = new Bullet(pos.x,pos.y,d+random(-10,10),'fireball.png');
					// audio.play('creek.wav',true,1);
					b1.speed = 15;
					bullets.push(b1);
				} else {
					// audio.stopAll();
				}
				if(this.cooldown2 < -300){
					this.cooldown2 = random(150,300);
					this.cooldown1 = 1;
					let d = Vector.getDir(x-player.pos.x,y-player.pos.y);
					this.direction = d;
				}
			}
		}
		class WaterBlob extends Sprite{
			constructor(x,y){
				super('waterblob/0.png');
				this.speed = .5;
				this.position = new Vector(x,y);
				this.cooldown = 60;
				this.maxHealth = 40;
				this.md = 80 * ((Math.random() > .5) ? -1 : 1);
				this.addAnimation('waterblob/waterblob.anims').then(()=>{
					this.animation.play('idle',true);
				});
				enemies.push(this);
			}
			attack(){
				let x = this.pos.x;
				let y = this.pos.y;
				let d = Vector.getDir(x-player.pos.x,y-player.pos.y);
				// this.direction = d;
				let pos = this.pos;
				// pos.x += this.speed * Math.cos(d*Math.PI/180);
				// pos.y += this.speed * Math.sin(d*Math.PI/180);
				// this.position = pos;
				this.cooldown--;
				if(this.cooldown == 0){
					this.cooldown = 300;
					for(let i=0;i<360;i+=360/8){
						let nb = new Bullet(pos.x,pos.y,i,'waterblob/waterbullet.png');
						bullets.push(nb);
					}
				}
			}
		}

		Sprite.prototype.health = 40;
		Sprite.prototype.healthBar = new Bar(0,0,50,10);
		Sprite.prototype.showHealth = function(){
			this.healthBar.pert = this.health / this.maxHealth;
			this.healthBar.draw(this.pos.x,this.pos.y-this.h/2-5);
		}
		Sprite.prototype.isTouchingLines = function(){
			for(let l of lines){
				if(this.touches(l)){
					return true;
				}
			}
			return false;
		}


		var classes = ['Tri1','FireFly','WaterBlob'];

		function spawnSprites(sprts){
			for(let sprite of sprts){
				let w = +sprite.w;
				setTimeout(()=>{
					let ns = eval(`new ${classes[sprite.i]}`);
					ns.position = new Vector(sprite.x,sprite.y);
				},w*1000);
			}
		}

		function EDITOR_CONTROLS(){
			if(sel_sprite && mouse.down){
				let ne = new Sprite(sel_sprite.path);
				ne.position = new Vector(mouse.pos.x-canvas.width/2+player.pos.x,mouse.pos.y-canvas.height/2+player.pos.y);
				sprites.push(ne);
				mouse.down = false;
				var w = 0;
				if(obj('#time_delay').checked){
					w = prompt('Enter delay (in seconds) before this item spawns');
				}
				level_data.spts.push({i:sel_sprite.ix,x:ne.pos.x,y:ne.pos.y,w});
			}
			if(mouse.down){
				if(DRAW_MODE==1){
					if(!o_pos){
						o_pos = new Vector(mouse.pos.x-canvas.width/2+player.pos.x,mouse.pos.y-canvas.height/2+player.pos.y);
					} else {
						ctx.beginPath();
						ctx.moveTo(o_pos.x,o_pos.y);
						ctx.lineTo(mouse.pos.x-canvas.width/2+player.pos.x,mouse.pos.y-canvas.height/2+player.pos.y);
						ctx.stroke();
					}
				}
			}
			if(!mouse.down){
				if(DRAW_MODE == 1){
					if(o_pos){
						lines.push(new Line(o_pos.x,o_pos.y,mouse.pos.x-canvas.width/2+player.pos.x,mouse.pos.y-canvas.height/2+player.pos.y));
						o_pos = null;
					}
				}
			}
			obj('#set_map').on('click',e=>{
				keys.keys['m'] = true;
			});
			if(keys.down('m')){
				keys.keys['m'] = false;
				let nm = prompt('Enter map Name');
				if(nm){
					loadMap(nm);
					level_data.map = nm;
					sprites = [];
					level_data.spts = [];
				}
			}
			obj('#spawn_point').on('click',e=>{
				level_data.sx = player.pos.x;
				level_data.sy = player.pos.y;
			});
			obj('#save').on('click',e=>{
				keys.keys['q'] = true;
			});
			if(keys.down('q')){
				if(!level_data.lines) level_data.lines = [];
				for(let l of lines){
					let p1 = l.getPosA();
					let p2 = l.getPosB();
					level_data.lines.push({x1:p1.x,y1:p1.y,x2:p2.x,y2:p2.y});
				}

				keys.keys['q'] = false;
				download('level0.json',JSON.stringify(level_data));
			}
			obj('#draw_line').on('click',e=>{
				if(sel_sprite) sel_sprite.el.classList.remove('selected');
				sel_sprite = null;
				DRAW_MODE = 1;
			});
		}


		function inputHandle(){
			let speed = 4;
			let pos = player.pos.clone();
			if(keys.down('w')){
				pos.y -= speed;
			}
			if(keys.down('s')){
				pos.y += speed;
			}
			if(keys.down('a')){
				pos.x -= speed;
				player.transformX = -1;
			}
			if(keys.down('d')){
				pos.x += speed;
				player.transformX = 1;
			}
			if(keys.down('e')){
				keys.keys['e'] = false;
				nWeapon();
			}

			pos.x = Math.max(Math.min(pos.x,background.w/2),-background.w/2);
			pos.y = Math.max(Math.min(pos.y,background.h/2),-background.h/2);
			let op = player.pos.clone();

			player.position = new Vector(pos.x,op.y);
			if(player.isTouchingLines()) pos.x = op.x;


			player.position = new Vector(op.x,pos.y);
			if(player.isTouchingLines()) pos.y = op.y;

			if(player.health > 0){
				player.position = pos;
				weapon.direction = Vector.getDir(canvas.width/2-mouse.pos.x,canvas.height/2-mouse.pos.y);
				weapon.position = Vector.getPointIn(weapon.dir * Math.PI / 180,weapon_dist,pos.x,pos.y);
			} else {
				player.position = op;
			}
			if(EDITOR){
				EDITOR_CONTROLS();
			}
		}

		var level_data = {spts:[],map:'sandmap',sx:0,sy:0,lines:[]};

		function useSpear(){
			weapon = new Sprite('spear/0.png');
			weapon.addAnimation('spear/stab.anims');
			weapon.scale = new Vector(1,.3);
			weapon.damage = 1;
			weapon_action = 'stab';
			weapon_dist = 25;
		}
		function useMace(){
			weapon = new Sprite('mace/0.png');
			weapon.addAnimation('mace/mace.anims');
			weapon_action = 'swing';
			weapon.damage = 3;
			weapon_dist = 20;
			weapon.transformX = -1;
		}
		function useLongSword(){
			weapon = new Sprite('longsword/0.png');
			weapon.addAnimation('longsword/longsword.anims');
			weapon_action = 'swing';
			weapon.damage = 3;
			weapon_dist = 40;
			weapon.transformX = -1;
		}
		function useKnives(){
			weapon = new Sprite('knives/0.png');
			weapon.addAnimation('knives/knife.anims');
			weapon_action = 'stab';
			weapon.damage = 3;
			weapon_dist = 15;
		}


		function attack(){
			try{
				weapon.animation.play(weapon_action).then(d=>{
					if(!d) return;
					for(let e of enemies){
						if(weapon.touches(e)){
							e.health -= weapon.damage;
							if(e.health <= 0){
								enemies.splice(enemies.indexOf(e),1);
								let poof = new Sprite('poof/0.png');
								poof.position = new Vector(e.pos.x,e.pos.y);
								poof.addAnimation('poof/poof.anims').then(e=>{
									poof.animation.play('poof').then(e=>{
										sprites.splice(sprites.indexOf(poof),1);
									});
								});
								sprites.push(poof);
							}
						}
					}
				})
			} catch(e){
				console.log('Animation didn\'t load fast enough');
			} 
		}

		var equips = [useSpear,useMace,useLongSword,useKnives];
		var weapon_ix = 0;

		function nWeapon(){
			if(player.health >= 0){
				weapon_ix = (weapon_ix+1) % equips.length;
				equips[weapon_ix]();
			}
		}

		var weapon;
		var weapon_action = '';
		var weapon_dist = 0;

		useSpear();

		function start(){
			if(!started){
				let lv_name = location.href.split('level=')[1];
				player.health = player.maxHealth;
				loadLevel(lv_name);
				if(EDITOR){
					setupTools();
				}
			}
			if(!FULLSCREEN) canvas.requestFullscreen();
		}

		async function loadLevel(level_name='level0'){
			stopGame();
			let req = await fetch(`levels/${level_name}.json`);
			level_data = await req.json();
			loadMap(level_data.map);
			if(!EDITOR) spawnSprites(level_data.spts);
			loadLines(level_data.lines);
			started = true;
			loop();
			if(EDITOR) level_data.spts = [];
			player.position = new Vector(level_data.sx,level_data.sy);
			if(!EDITOR) canvas.requestFullscreen();
		}

		Hitbox.show = false;

		var started = false;

		function stopGame(){
			started = false;
			if(typeof GAME == 'number') clearTimeout(GAME);
		}

		function loop(){
			ctx.clearRect(-2,-2,canvas.width+2,canvas.height+2);
			GAME = setTimeout(loop,1000/60);
			ctx.save();
			ctx.translate(-player.pos.x+canvas.width/2,-player.pos.y+canvas.height/2);
			background.draw();
			inputHandle();
			player.draw();
			player.showHealth();
			if(player.health <= 0){
				player.health = 0;
				player.direction = 90;
			}
			for(let s of sprites) s.draw();
			if(!EDITOR){
				for(let b of bullets){
					b.fly();
					b.draw();
				}
			}
			if(EDITOR || Hitbox.show){
				for(let l of lines){
					l.draw();
				}
			}
			for(let e of enemies){
				if(!EDITOR) e.attack();
				e.draw();
				e.showHealth();
			}
			weapon.draw();
			if(mouse.down && !EDITOR && player.health > 0){
				attack();
			}
			ctx.restore();
		}

		function shoot(){
			let x = random(0,canvas.width);
			let y = 0;
			// let d = Vector.getDir(x-player.pos.x,y-player.pos.y);
			let d = 90;
			let nb = new Bullet(x,y,d);
			bullets.push(nb);
		}

	</script>
</body>
</html>