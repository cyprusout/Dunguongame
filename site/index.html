<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<link rel="icon" type="image/x-icon" href="icon.png">
	<style>
		canvas{
			background-color:black;
		}
		game{
			display: flex;
		}
		div > img{
			box-sizing: border-box;
			border: 0;
		}
		.selected{
			border: 2px solid red;
		}
		#edit{
			visibility: hidden;
		}
	</style>
	<script src="helpers.js"></script>
	<script src="sprite.js"></script>
	<script src="input.js"></script>
	<script src="audio.js"></script>
</head>
<body>
	<game>
		<canvas width=1200 height=800></canvas>
		<div id=edit>
			<button id=set_map>Choose Map</button>
			<button id=spawn_point>Set Spawn Point</button>
			<button id=draw_line>Draw Collision Line</button>
			<button id=draw_circle>Draw Collision Circle</button>
			<button id=save>Download Level</button>
			<input title="Sprite Spawn Delay" id=time_delay type=checkbox>
			<br>
		</div>
	</game>
	<script>
		const canvas = obj('canvas');
		const ctx = canvas.getContext('2d');
		ctx.fillStyle = 'white';
		ctx.font = '40px sans-serif';
		ctx.fillText('Press Space to Start',50,50);
		ctx.fill();

		//////////////////////////////////////////////////
		var EDITOR = location.href.includes('editor');
		//////////////////////////////////////////////////

		var sel_sprite=null;

		var player = new Sprite('Player/0.png');

		var bullets = [];
		var enemies = [];
		var sprites = [];
		var GAME = 0;

		document.on('keydown',e=>{
			if(e.key == ' '){
				start();
			}
		});

		keys.start();
		mouse.start(canvas);

		var background;

		function loadMap(name='sandmap'){
			background = new Sprite(name+'.png');
			background.position = new Vector(0,0);
		}

		loadMap();

		class Bullet extends Sprite{
			constructor(x,y,d,path='bullet.png'){
				super(path);
				this.position = new Vector(x,y);
				this.direction = d;
				this.speed = 3.5;
			}
			fly(){
				let pos = this.pos;
				pos.x += this.speed * Math.cos(this.dir*Math.PI/180);
				pos.y += this.speed * Math.sin(this.dir*Math.PI/180);
				this.position = pos;
				if(pos.y > background.h/2 || pos.y < -background.h/2 || pos.x < -background.w/2 || pos.x > background.w/2){
					bullets.splice(bullets.indexOf(this),1);
				}
			}
		}

		var imgs = [
			{ix:0,name:'Tri1',path:'bushman.png'},
			{ix:1,name:'FireFly',path:'fireshooter.png'},
			{ix:2,name:'WaterBlob',path:'waterblob/0.png'},
		];

		function setupTools(){
			show(obj('#edit'));
			for(let sprite of imgs){
				let i = new Image;
				i.src = sprite.path;
				i.width = 50;
				obj('#edit').appendChild(i);
				sprite.el = i;
				i.on('click',e=>{
					if(sel_sprite) sel_sprite.el.classList.remove('selected');
					sel_sprite = sprite;
					i.classList.add('selected');
				})
			}
		}

		class Tri1 extends Sprite{
			constructor(x,y){
				super('bushman.png');
				this.speed = .5;
				this.position = new Vector(x,y);
				this.cooldown = 60;
				this.md = 80 * ((Math.random() > .5) ? -1 : 1);
				enemies.push(this);
			}
			attack(){
				let x = this.pos.x;
				let y = this.pos.y;
				let d = Vector.getDir(x-player.pos.x,y-player.pos.y);
				this.direction = d;
				let pos = this.pos;
				d += this.md;
				pos.x += this.speed * Math.cos(d*Math.PI/180);
				pos.y += this.speed * Math.sin(d*Math.PI/180);
				this.position = pos;
				this.cooldown--;
				d -= this.md;
				if(this.cooldown == 0){
					this.cooldown = 60;
					let b1 = new Bullet(pos.x,pos.y,d);
					let b2 = new Bullet(pos.x,pos.y,d-35);
					let b3 = new Bullet(pos.x,pos.y,d+35);
					bullets.push(b1,b2,b3);
				}
			}
		}
		class FireFly extends Sprite{
			constructor(x,y){
				super('fireshooter.png');
				this.speed = 3;
				this.position = new Vector(x,y);
				this.cooldown1 = 2;
				this.cooldown2 = -200;
				this.md = 0 * ((Math.random() > .5) ? -1 : 1);
				enemies.push(this);
			}
			attack(){
				let x = this.pos.x;
				let y = this.pos.y;
				let pos = this.pos;
				let d = this.dir;
				pos.x += this.speed * Math.cos(d*Math.PI/180);
				pos.y += this.speed * Math.sin(d*Math.PI/180);
				this.position = pos;
				this.cooldown1--;
				this.cooldown2--;
				if(this.cooldown1 == 0 && this.cooldown2 > 0){
					this.cooldown1 = 1;
					let b1 = new Bullet(pos.x,pos.y,d+random(-10,10),'fireball.png');
					// audio.play('creek.wav',true,1);
					b1.speed = 15;
					bullets.push(b1);
				} else {
					// audio.stopAll();
				}
				if(this.cooldown2 < -300){
					this.cooldown2 = random(150,300);
					this.cooldown1 = 1;
					let d = Vector.getDir(x-player.pos.x,y-player.pos.y);
					this.direction = d;
				}
			}
		}
		class WaterBlob extends Sprite{
			constructor(x,y){
				super('waterblob/0.png');
				this.speed = .5;
				this.position = new Vector(x,y);
				this.cooldown = 60;
				this.md = 80 * ((Math.random() > .5) ? -1 : 1);
				this.addAnimation('waterblob/waterblob.anims').then(()=>{
					this.animation.play('idle',true);
				});
				enemies.push(this);
			}
			attack(){
				let x = this.pos.x;
				let y = this.pos.y;
				let d = Vector.getDir(x-player.pos.x,y-player.pos.y);
				// this.direction = d;
				let pos = this.pos;
				// pos.x += this.speed * Math.cos(d*Math.PI/180);
				// pos.y += this.speed * Math.sin(d*Math.PI/180);
				// this.position = pos;
				this.cooldown--;
				if(this.cooldown == 0){
					this.cooldown = 300;
					for(let i=0;i<360;i+=360/8){
						let nb = new Bullet(pos.x,pos.y,i,'waterblob/waterbullet.png');
						bullets.push(nb);
					}
				}
			}
		}


		var classes = [Tri1,FireFly,WaterBlob];

		let r_c = 0;
		function spawnEnemy(){
			let ne;
			// let r = random(1,2);
			let r = 1+(r_c++)%2;
			if(r==1){
				ne = new Tri1(random(-background.w/2,background.w/2),random(-background.h/2,background.h/2));
			} else if(r==2){
				// ne = new FireFly(random(-background.w/2,background.w/2),random(-background.h/2,background.h/2));
				ne = new FireFly(player.pos.x,player.pos.y+500);
			}
			enemies.push(ne);
		}

		function spawnSprites(sprts){
			for(let sprite of sprts){
				let w = +sprite.w;
				setTimeout(()=>{
					let ns = eval(`new ${classes[sprite.i]}`);
					ns.position = new Vector(sprite.x,sprite.y);
				},w*1000);
			}
		}

		function EDITOR_CONTROLS(){
			if(sel_sprite && mouse.down){
				let ne = new Sprite(sel_sprite.path);
				ne.position = new Vector(mouse.pos.x-canvas.width/2+player.pos.x,mouse.pos.y-canvas.height/2+player.pos.y);
				sprites.push(ne);
				mouse.down = false;
				var w = 0;
				if(obj('#time_delay').checked){
					w = prompt('Enter delay (in seconds) before this item spawns');
				}
				level_data.spts.push({i:sel_sprite.ix,x:ne.pos.x,y:ne.pos.y,w});
			}
			obj('#set_map').on('click',e=>{
				keys.keys['m'] = true;
			});
			if(keys.down('m')){
				keys.keys['m'] = false;
				let nm = prompt('Enter map Name');
				if(nm){
					loadMap(nm);
					level_data.map = nm;
					sprites = [];
					level_data.spts = [];
				}
			}
			obj('#spawn_point').on('click',e=>{
				level_data.sx = player.pos.x;
				level_data.sy = player.pos.y;
			});
			obj('#save').on('click',e=>{
				keys.keys['q'] = true;
			});
			if(keys.down('q')){
				keys.keys['q'] = false;
				download('level0.json',JSON.stringify(level_data));
			}
		}

		function inputHandle(){
			let speed = 4;
			let pos = player.pos;
			if(keys.down('w')){
				pos.y -= speed;
			}
			if(keys.down('s')){
				pos.y += speed;
			}
			if(keys.down('a')){
				pos.x -= speed;
				player.transformX = -1;
			}
			if(keys.down('d')){
				pos.x += speed;
				player.transformX = 1;
			}
			if(keys.down('e')){
				keys.keys['e'] = false;
				nWeapon();
			}
			player.slideTo(pos.x,pos.y);
			weapon.direction = Vector.getDir(canvas.width/2-mouse.pos.x,canvas.height/2-mouse.pos.y);
			weapon.position = Vector.getPointIn(weapon.dir * Math.PI / 180,weapon_dist,pos.x,pos.y);
			if(EDITOR){
				EDITOR_CONTROLS();
			}
		}

		var level_data = {spts:[],map:'sandmap',sx:0,sy:0};

		function useSpear(){
			weapon = new Sprite('spear/0.png');
			weapon.addAnimation('spear/stab.anims');
			weapon.scale = new Vector(1,.3);
			weapon_action = 'stab';
			weapon_dist = 25;
		}
		function useMace(){
			weapon = new Sprite('mace/0.png');
			weapon.addAnimation('mace/mace.anims');
			weapon_action = 'swing';
			weapon_dist = 20;
			weapon.transformX = -1;
		}
		function useLongSword(){
			weapon = new Sprite('longsword/0.png');
			weapon.addAnimation('longsword/longsword.anims');
			weapon_action = 'swing';
			weapon_dist = 40;
			weapon.transformX = -1;
		}
		function useKnives(){
			weapon = new Sprite('knives/0.png');
			weapon.addAnimation('knives/knife.anims');
			weapon_action = 'stab';
			weapon_dist = 15;
		}

		var equips = ['useSpear','useMace','useLongSword','useKnives'];
		var weapon_ix = 0;
		function nWeapon(){
			weapon_ix = (weapon_ix+1) % equips.length;
			equips[weapon_ix]();
		}

		var weapon;
		var weapon_action = '';
		var weapon_dist = 0;

		useSpear();

		function start(){
			if(!started){
				let lv_name = location.href.split('level=')[1];
				loadLevel(lv_name);
				if(EDITOR){
					setupTools();
				}
			}
		}

		async function loadLevel(level_name='level0'){
			stopGame();
			let req = await fetch(`levels/${level_name}.json`);
			level_data = await req.json();
			player.position = new Vector(level_data.sx,level_data.sy);
			loadMap(level_data.map);
			if(!EDITOR) spawnSprites(level_data.spts);
			started = true;
			loop();
			if(!EDITOR) canvas.requestFullscreen();
			if(EDITOR) level_data.spts = [];
		}

		Hitbox.show = false;

		let i = 0;
		var max_enemies = 6;
		var started = false;

		function stopGame(){
			started = false;
			if(typeof GAME == 'number') clearTimeout(GAME);
		}

		function loop(){
			ctx.clearRect(-2,-2,canvas.width+2,canvas.height+2);
			GAME = setTimeout(loop,1000/60);
			ctx.save();
			ctx.translate(-player.pos.x+canvas.width/2,-player.pos.y+canvas.height/2);
			inputHandle();
			background.draw();
			player.draw();
			if(i++ % 1000 == 0 && enemies.length < max_enemies && !EDITOR){
				// spawnEnemy();
			}
			for(let s of sprites) s.draw();
			if(!EDITOR){
				for(let b of bullets) b.fly();
				for(let b of bullets) b.draw();
				for(let e of enemies) e.attack();
			}
			for(let e of enemies) e.draw();
			weapon.draw();
			if(mouse.down && !EDITOR){
				try{
					weapon.animation.play(weapon_action);
				} catch(e){
					console.log('Animation didn\'t load fast enough');
				} 
			}
			ctx.restore();
		}

		function shoot(){
			let x = random(0,canvas.width);
			let y = 0;
			// let d = Vector.getDir(x-player.pos.x,y-player.pos.y);
			let d = 90;
			let nb = new Bullet(x,y,d);
			bullets.push(nb);
		}

	</script>
</body>
</html>